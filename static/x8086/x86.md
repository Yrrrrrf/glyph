# 16-bit BIOS Assembly

- [instruction set reference](https://www.felixcloutier.com/x86/)

Welcome to assembly programming on the "bare metal." In this environment, you
are in total control. **There is no operating system holding your hand**. You
will speak directly to the CPU and the computer's firmware (the BIOS).

# The Anatomy of a `.com` Program

Every program you write for your [`emu2`](https://github.com/dmsc/emu2)
environment will be a `.com` file and must follow a simple structure.

```assembly
; This is a comment. Always comment your code!

section .data
    ; Data like strings and variables are defined here.

section .text
    global _start

org 0x100      ; CRITICAL: All .com programs start at memory address 100h.
               ; This tells the assembler to calculate memory locations from here.

_start:
    ; Your code's execution begins here.

    ; --- Program Logic ---

    ; Proper way to exit a .com program
    mov ah, 0x4C
    int 0x21
```

# The CPU's Scratchpad: Registers

You don't have variables. You have a few super-fast storage locations on the CPU
called registers. Mastering them is key.

## General Purpose Registers (The Workhorses)

These are 16-bit registers that can also be addressed as two 8-bit halves.

| 16-bit | High 8-bit | Low 8-bit | Common Use                                                                           |
| :----- | :--------- | :-------- | :----------------------------------------------------------------------------------- |
| `AX`   | `AH`       | `AL`      | **Accumulator**: Used for arithmetic, I/O, and interrupts. The most important one!   |
| `BX`   | `BH`       | `BL`      | **Base**: Used to hold memory addresses (pointers).                                  |
| `CX`   | `CH`       | `CL`      | **Counter**: Used as a counter in loops.                                             |
| `DX`   | `DH`       | `DL`      | **Data**: A general data register, often used with `AX` for multiplication/division. |

_Example:_ `mov ax, 1000` moves 1000 into `AX`. `mov al, 5` moves 5 into the
lower half of `AX`, changing its value.

## Index & Pointer Registers (For Memory)

These are primarily used to point to locations in memory.

| 16-bit | Name              | Common Use                                                              |
| :----- | :---------------- | :---------------------------------------------------------------------- |
| `SI`   | Source Index      | Points to a memory source in data operations.                           |
| `DI`   | Destination Index | Points to a memory destination.                                         |
| `SP`   | Stack Pointer     | Points to the top of the stack. **Don't change this manually!**         |
| `BP`   | Base Pointer      | Points to the base of the current stack frame (for function arguments). |

# The Core Instruction Set

This is the bread and butter of your programs.

## Data Movement

- `mov dest, src` - Copies data from `src` to `dest`.
  - `mov ax, 123` (Immediate value)
  - `mov bx, ax` (From another register)
  - `mov al, [my_message]` (From memory, `[]` means "contents of the address")
- `push value` - Pushes a value onto the stack (a temporary storage area).
- `pop dest` - Pops a value from the stack into a destination.

## Arithmetic

- `add dest, value` - `dest = dest + value`
- `sub dest, value` - `dest = dest - value`
- `inc reg` - Increment: `reg = reg + 1`
- `dec reg` - Decrement: `reg = reg - 1`

## Control Flow (Making Decisions)

This is a two-step process: `compare` then `jump`.

- `cmp val1, val2` - Compares two values and sets internal CPU flags. It does
  **not** change the values.
- **Conditional Jumps**: These instructions read the CPU flags and jump to a
  label if the condition is true.
  - `je <label>` - Jump if Equal
  - `jne <label>` - Jump if Not Equal
  - `jg <label>` - Jump if Greater
  - `jl <label>` - Jump if Less
  - `jge <label>` - Jump if Greater or Equal
  - `jle <label>` - Jump if Less or Equal
- `jmp <label>` - **Unconditional Jump**. Always jumps to the label.

## Procedures (Functions)

- `call <label>` - Pushes the return address to the stack and jumps to the
  procedure.
- `ret` - Pops the return address from the stack and jumps back.

# Defining Data

You define your data (like strings) in the `.data` section.

- `db` - **Define Byte**. Allocates 1 byte of storage.
- `dw` - **Define Word**. Allocates 2 bytes (a "word" in 16-bit assembly).

```assembly
section .data
    my_message  db 'Hello, World!', 0x0D, 0x0A, 0  ; A string.
                                                   ; 0x0D, 0x0A is a newline.
                                                   ; 0 is the "null terminator" to mark the end.
    my_number   dw 42                              ; A 16-bit number.
```

# The "API": Talking to the BIOS & DOS

You can't do anything useful without asking the hardware for help. You do this
with the `int` (interrupt) instruction. `emu2` supports both BIOS and some basic
DOS interrupts.

You choose a function by putting a value in the `AH` register before the `int`
call.

## Most Important Interrupts

- **`int 0x10` (BIOS Video Services)**
  - `AH = 0x0E`: **Print a character.** The character must be in `AL`.
- **`int 0x16` (BIOS Keyboard Services)**
  - `AH = 0x00`: **Wait for and read a key press.** The result is stored in
    `AX`.
- **`int 0x21` (DOS Services)** - _Often easier to use!_
  - `AH = 0x02`: **Print a character.** The character must be in `DL`.
  - `AH = 0x09`: **Print a string.** `DX` must point to the memory address of
    the string. The string **must** end with a `$` character.
  - `AH = 0x4C`: **Exit the program.** This is the standard way to end a `.com`
    file.

# Putting It All Together: A Complete Example

This program prints "Hello!" to the screen character by character using a loop.
Study it carefully. It uses nearly everything discussed above.

```assembly
; hello-world.asm
; A complete, working program for your 16-bit environment.

section .data
    msg db 'Hello!', 0 ; Our message, ending with a null byte.

section .text
    global _start

org 0x100

_start:
    mov si, msg     ; Point the SI (Source Index) register to our message.

print_loop:
    mov al, [si]    ; Copy the byte that SI is pointing to into AL.
    cmp al, 0       ; Compare the character with the null terminator (0).
    je exit_program ; If it's zero (Jump if Equal), we're done, so jump to the exit.

    ; If it's not zero, we print the character.
    mov ah, 0x0E    ; Use BIOS function 0Eh (teletype output).
    int 0x10        ; Call BIOS video interrupt.

    inc si          ; Increment SI to point to the next character in the message.
    jmp print_loop  ; Jump back to the start of the loop.

exit_program:
    hlt             ; Halt the processor. We are done.
```
